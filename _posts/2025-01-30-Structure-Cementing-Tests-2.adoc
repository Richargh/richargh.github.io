---
title: Structure-cementing tests and how to avoid them 2/3
tags: testing architecture cementing
comments: false
---

NOTE: This article was originally published in link:https://www.ijug.eu/de/java-aktuell/zeitschrift/java-aktuell-archiv/detailansicht-java-aktuell/java-aktuell-5-24-cloud/[Java Aktuell 5/24] in 🇩🇪. It is translated and republished here with the magazine's permission.

== Part 2 - Concepts of the TestDsl

_Tests should react to behavioural changes but be insensitive to structural changes. Tests that do not fulfil the second condition are called structure-cementing. In link:Structure-Cementing-Tests-1[part 1], we built a test DSL with which we can completely avoid cementing through the test setup. In this part, we will go into more detail about the concepts of the DSL and show why you can use it to write tests that become unit tests after changing just one line of integration._

The DSL (Domain-Specific Language <<dsl>>) implemented in link:Structure-Cementing-Tests-1[part 1] is an abstraction layer between test and test setup. It is used to decouple the actual test from the preconditions, more precisely how these preconditions are created. For example, a method to be tested `rentBook(bookId, userId)` in a `RentingService` could have the precondition that the book and user must be stored in a `Repository` before we call `rentBook`. A user may also have a `role` and this must also already be stored, just like the `permission` of the role.

If you were to create all the preconditions in each test by hand, you would not only have created a lot of redundancy, but (assuming enough tests) you would also have cemented the structure of all the preconditions. Implementation details, such as what a `Role` looks like, how it gets into its `Repository`, how the `RentingService` gets to that `Repository`, are cemented with every redundant test setup. The respective engineer then simply does not feel like touching x files in order to implement an actually sensible structural change afterwards. Our structure is cemented.

If the entire test setup is done via the Dsl (<<fig:testdsl-structure, see figure>>), only the Dsl is affected by structure changes and the test is decoupled from the structure. We can make structural changes in the production code without any problems because we only have to make changes in one place, in the Dsl.

[[fig:testdsl-structure]]
.The TestDsl inserts itself between tests and the structure of the production code
image::/assets/img/posts/structure-cementing-tests/part2/LL-Test-Dsl-Layer.png[At the top are the tests. The tests only have dependencies on the Test-D.S.L. The Test-D.S.L. has dependencies on the production code. If production code changes only the D.S.L. has to change but not a single test.]

The TestDsl consists of the parts:

* TestState
* Floor
* Entity (Combo) Builder
* Test Doubles (instead of structure-cementing mocks)
* Service Configurator (optional)
* JUnit extension (optional)

A noticeable amount of code, but not much logic. It's actually always about delegating or setting values. The Dsl should think as little as possible so that we don't create a maintenance problem.

Clearly, we need to invest code. However, this pays dividends quickly and allows us to write very concise tests (<<lst:testdsl-complete-test-w-extension, the final test from part 1>>):

[[lst:testdsl-complete-test-w-extension]]
.Complete test with TestDsl Extension
[source,java]
----
@Integration @Test
void should_be_able_to_rent_book(TestState a, Floor floor){
    // given
    var book = a.book();
    var userCombo = a.userCombo(it -> it.hasPermission("CAN_RENT_BOOK"));
    a.saveTo(floor);

    var testee = new RentingService(floor);
    // WHEN
    var result = testee.rentBook(book, userCombo.user());
    // THEN
    assertThat(result.isRented()).isTrue();
}
----

We can now also turn the test from <<lst:testdsl-complete-test-w-extension>> into a quick `@Unit` test just by changing the `@Integration` annotation. Legacy code in particular benefits from this, because we often still have a lot of logic in the database and have to test at integration level before remediation. Over time, this logic ends up in the domain and we can turn existing tests into significantly faster unit tests with a one-liner. Without a TestDsl, you would have to completely rewrite them at unit level, which is why many teams do not do this, remain stuck with slow integration tests and cannot iterate faster despite tests

In the following, we will see why this is possible and which concepts are behind the Dsl. In Part 3, we will look at the second and final type of structure-cementing tests: Tests that test unstable elements and not modules.

== Unit and integration tests

Unit and integration tests are very vague terms across the industry (<<test-shapes>>, <<google-test-sizes>>). Even in small teams there is no clear definition, everyone has their own understanding. So we should pause for a moment and define what we are actually talking about when we say `@Unit @Test`.

The test written in part 1 is a Sociable Unit Test <<fowler-unit-test>> and follows the unit test definition by Michael Feathers <<feathers-unit-test>>:

[quote, Michael Feathers [5]]
____
A test is not a unit test if:

- It talks to the database
- It communicates across the network
- It touches the file system
- It can't run at the same time as any of your other unit tests
- You have to do special things to your environment (such as editing config files) to run it.

Tests that do these things aren't bad. Often they are worth writing, and they can be written in a unit test harness. However, it is important to be able to separate them from true unit tests so that we can keep a set of tests that we can run fast whenever we make our changes.
____

Around 2010, Google did not know this definition or their teams could not agree on it.
However, they knew that it was practical for internal company exchange if everyone had the same understanding of tests and therefore introduced new 'data-driven naming conventions' for tests.
Their definition of a small test is pretty close to Feathers' definition (<<tbl:google-test-sizes, Google Test Sizes>>) and the medium test provides a pretty good definition of an integration test.

[[tbl:google-test-sizes]]
.Google Test Sizes <<google-test-sizes>>
[cols="1,2,4" options="header,footer"]
|===
| Feature
| Small (Unit)
| Medium (Integration)
| Large (Acceptance)

| Database
| No
| Yes
| Yes

| Network access
| No
| localhost only
| Yes

| File system access
| No
| Yes
| Yes

| Use external systems
| No
| Discouraged
| Yes

| Multiple threads
| No
| Yes
| Yes

| Sleep statements
| No
| Yes
| Yes

| System properties
| No
| Yes
| Yes

| Time limit (seconds)
| 60
| 300
| 900+
|===

The table also shows why unit tests are so fast: there is no _out-of-process_ with which our tested code has to interact.
Everything runs _in-process_ and _in-memory_ and without _network_.
The perfect basis for the majority of our tests, because the next level of integration or medium can already be significantly slower.
Depending on the test runner and infrastructure, unit tests in customer projects are between 4 and 10 times faster than integration tests.
We were only able to achieve a factor of 4 with our integration tests by parallelising them with a little trickfootnote:[If each test is given its own namespace in the database (in MongoDb this would be a schema), then each integration test can only see its own data and can only modify its own data. Test isolation is thus restored.].

== From integration to unit test

We can convert our test (<<lst:testdsl-complete-test-w-extension>>) from `@Integration` to `@Unit` with a one-liner. The JUnit extension now exchanges all repositories in the background. Thus, `InMemoryBooksDouble` becomes the production repository `JpaBooks`. The api of the TestDsl remains the same, which is why we no longer need to make any changes to the test. We don't have to change anything in the tested code either, because it only contains the `interface Books { add(Book book); /* ... */ }` and not which implementation is behind it.

For this change to work so smoothly, however, the _InMemory_ and _Jpa_ repositories must also behave in the same way. In the following chapter, we will see how we can continuously ensure this with the so-called port contract tests.

However, it does not always make sense to implement all methods of `Books` in `InMemoryBooksDouble` and to keep them synchronised with port contract tests. Sometimes we need the powerful query functionalities of databases not for business logic, but for search functions in the UI. On the one hand, it would be a huge overhead to rebuild these in-memory for a few `@Unit` tests. On the other hand, these tests would then really only test our InMemory repository implementation. In such cases, we prefer to throw a `NotImplementedException` in the InMemory double and stick with `@Integration` tests (for now). We can always change our mind if business logic actually requires the query method.

== Keeping doubles synchronised to production code with port contract tests

So far we have assumed that a _Jpa_- can always be replaced by an _InMemory_ repository. This is possible because we combine the _Ports & Adapters Architecture_ <<ports-and-adapters>> with so-called port contract tests <<richargh-contract-tests>>.

_JpaBooks_ implements the interface _Books_. The interface is a so-called **port**. All classes that implement the interface are **adapters** of it. However, the domain logic only knows the ports and not which implementation is behind them. This means that we have decoupled the domain logic from what the code that communicates with the outside world actually looks like. Theoretically, an implementation of the port does not even have to exist when writing the domain logic.

The _Ports & Adapters Architecture_ <<ports-and-adapters>> helps us to model better. We can model the domain logic first before we have to turn to implementation details. On the other hand, the architecture also offers us the option of replacing real adapters with test doubles <<xunit-test-double>> for tests. In our unit tests, we therefore use an _InMemoryBooksDouble_ instead of a slower and more expensive _JpaBooks_ repository.

_InMemoryBooksDouble_ is a specific type of double, a so-called _fake_ <<xunit-fake>>. In contrast to the other double types (dummies, stubs, spies and mocks <<mocks-arent-stubs>>), fakes are working implementations of ports that take shortcuts that the production code cannot take, in this case the InMemory solution.

In contrast to other doubles, however, the fake must fulfil the expectations that the domain code has of the port. With repositories, for example, the domain code expects that an entity that was added with `add()` can then also be found again with a `find()`. The expectations that the domain has of the port are called *contract* and we can check them with a *port contract test* (<<lst:port-contract-test>>).

[[lst:port-contract-test]]
.Port Contract Test of our Port
[source,java]
----
public abstract class BooksContract { // <1>
    abstract Books testee(); // <2>

    @Test
    void should_remember_book(TestState a){ // <3>
        // given
        var book = a.book();
        var testee = testee();
        // when
        testee.add(book);
        // then
        assertThat(testee.findById(book.id())).isEqualTo(book);
    }
}
----
<1> The contract is abstract. It only becomes an executable test when it is implemented.
<2> We only know the port in the test, not the implementation.
<3> Each test describes behaviour that we expect from the port.

The implementation test is very short for both the fake (<<lst:port-adapter-test>>) and the production adapter.

[[lst:port-adapter-test]]
.Test of the Port Adapter
[source,java]
----
@Unit
public class InMemoryBooksTest extends BooksContract {

    @Override
    Books testee() { // <1>
        return new InMemoryBooks();
    }
}
----
<1> Adapter tests usually only implement the method that creates the `testee`.

And the fake is also very easy to write (<<lst:inmemory-books-fake>>) thanks to a reusable base (<<lst:base-inmemory-fake>>).

[[lst:inmemory-books-fake]]
.An InMemory fake is quick to write thanks to the base class
[source,java]
----
public class InMemoryBooksDouble
            extends BaseInMemoryDouble<BookId, Book>
            implements Books { // <1> <2>
}
----
<1> In most repositories, we do not need to implement any special methods here and only use what the base also has.
<2> Special methods are usually only created by queries. We can solve simple queries with the `filter(predicate)` method from the base class (<<lst:base-inmemory-fake>>). For more complex filter methods, however, we can always say that we do not implement them and prefer to use a slower _Integration Test_.

[[lst:base-inmemory-fake]]
.The base class has little logic and always delegates to the JDK map
[source,java]
----
public abstract class BaseInMemoryDouble<TId, TEntity extends Entity<TId>> {
    private Map<TId, TEntity> entities = new HashMap<>(); // <1>

    public List<TEntity> filter(Predicate<TEntity> predicate){
        return this.entities.values().stream()
                    .filter(predicate)
                    .toList(); // <2>
    }

    // <3>
}
----
<1> For tests, we only need one HashMap here. However, if we also intend to test parallel code, we should use a ConcurrentHashMap straight away.
<2> Simple queries can be solved using predicate. For our unit tests, we don't need anything complicated with indices because our HashMap only contains a few entities.
<3> Other methods such as `findById()`, `add()`, `remove()`, `removeIf()` and `count()` only pass through to the (concurrent) HashMap. We do not implement anything special here, but use what the JDK gives us.

With these tests, we can now guarantee that all adapters of the port behave in the same way. They will always be synchronised with what we define as an expectation (aka contract) in the tests.

Contract tests are an idea from J. B. Rainsberger <<contract-tests>>. We only call them **port** contract tests here to make it more explicit which contract you want to test. This also distinguishes them from the **integration** contract tests <<integration-contract-tests>> and the consumer-driven contracts <<consumer-driven-contracts>> approach. An alternative name for the port contract tests is role tests <<role-tests>>.

== Structure-cementing mocks and flexible doubles

In our test, we have so far only used one form of _Test Doubles_ <<xunit-test-double>>, the InMemory _Fakes_ <<xunit-fake>>. In addition to the fakes, there are also _stubs_, _spies_ and _mocks_. They are defined as follows:

Fakes <<xunit-fake>>::
are working implementations that can take shortcuts that the production code cannot take. We keep them synchronised with port contract tests. Fakes can be recognised by the fact that their implementation does roughly the same as the production implementation.
Stubs <<xunit-stub>>::
allow us to put **indirect inputs** into our test. Indirectly, because these inputs are not passed as parameters to the testee, but the testee pulls the inputs itself. Stubs can be recognised by the fact that we pass them test data, which they return as bluntly as possible when requested by the testee. There is no great logic here.
Mocks <<xunit-mock>>::
allow us to check **indirect outputs** from our testee. Indirectly, because you don't get these outputs as a return value from the testee, but have to retrieve and verify them via detours. This is also known as behaviour verification. Mocks can be recognised by the fact that you ask the mock directly to verify whether it has been called (with certain parameters). The test calls a framework method (`verify(mock).sth(param)`) or a self-written method (`mock.verifyAddWasCalled()`).

All three _Test Doubles_ can be implemented with a mocking framework, but a mocking framework only makes sense for the mocks. Since you only need mocks very rarely, you only need a mocking framework very rarely. This is good because the excessive use of the framework also leads to structure cementation (<<fig:structure-cement-mock>>).

[[fig:structure-cement-mock]]
.Reimplementation of the same method in n tests leads to structure cementation
image::/assets/img/posts/structure-cementing-tests/part2/Cement-structure-via-mock.png[Visualizes that reimplementing the behavior of classes via mocks cements the structure of the production code.]

If we reimplement the same methods again and again in _n_ tests, then:

1. we cement the design at the type level.
2. our reimplementation may deviate from the real code. The deviation can even be so strong that we break the encapsulation of the port <<stubs-and-mocks-break-encapsulation>>.

The former deprives us of the possibility to change our structure. But the latter is perhaps even worse, because our test can be green with the mock, although it would be red with the production code. As a result, we no longer trust our tests.

In ‘The Art of Unit Testing’ <<art-of-unit-testing>>, the recommendation is to only use mocks if we want to test the interaction with an external service. Then you only need mocks in 2% to 5% of unit tests.

For the vast majority of tests, we therefore use either no double at all (method that only calculates and we can assert on the return value), an (in-memory) fake or a stub and we then write these quickly by hand (fake -> <<lst:base-inmemory-fake>>) or stub -> (<<lst:remote-service-stub>>).

[[lst:remote-service-stub]]
.A simple stub
[source,java]
----
public class IsbnApiEchoDouble { // <1>

    private final String bookTitleEcho;

    public SomeRemoteApiEchoDouble(String bookTitleEcho){
	    this.bookTitleEcho = bookTitleEcho != null
                                            ? bookTitleEcho
                                            : "Refactoring";
    }

    public String findTitle(Isbn isbn) {
        return this.bookTitleEcho; // <2>
    }
}
----
<1> There are different types of stubs. This one always returns an echo of the values it received in the constructor.
<2> No special logic here. Just return what you got in the constructor.

Writing it yourself also gives us a single place where we can maintain structural changes to the real port without affecting the test.

== Builder Design

The generic `with()` method accelerates the writing of the initial builder (<<lst:builder-design>>) but requires _public_ fields.

[[lst:builder-design]]
.Entity-TestBuilder
[source,java]
----
public class BookBuilder extends TestBuilder<Book> {

    public BookId id = ids.next(BookId.class);
    public String title = "Refactoring";
    public String author = "Martin Fowler";
    public Instant createdOn = clock.now();

    public BookBuilder(Clock clock, Ids ids){
        super(clock, ids);
    }

    public Book build(){
        return new Book(id, title);
    }

    public BookBuilder with(Consumer<? super BookBuilder> action) {
        action.accept(this);
        return this;
    }

}
----

So far we have taken the trade-off. But there are situations where you can switch and more specific `withX()` or `isX()` become useful:

1. the new methods make testing more convenient.
2. if two or more fields can only be changed together.

The first happens if we decide, for example, to type the author name not with _stringly_ but **strongly** <<stringly-typed>> as `AuthorName` in order to have more _Compile-Time Safety_ similar to the Ids. Then the generic `with()` method is no longer as convenient to use, because we always have to write `with(it -> { author = new AuthorName(‘Alistair’); })`. We can then introduce a `withAuthor(String name)` and a `withAuthor(AuthorName name)` overload to make tests more flexible and readable.

The fact that two or more fields depend on each other happens, for example, when a `Book` gets a field `rentedOn`. `rentedOn` must always be after `createdOn`. With our generic `with()`, however, we can create an object that is invalid because we have only set `rentedOn`. This is not a big problem if we always validate in the constructor of a class or record whether the fields (aka the state) are correct. However, `BookBuilder` would then allow something, which `Book` then acknowledges in runtime with an `IllegalArgumentException`.

In order to have more compile-time safety again, we can make `rentedOn` private again in the builder and introduce `isRentedOn(Duration rentedAfterCreate)` together with the overload `isRentedOn(Instant createdOn, Duration rentedAfterCreate)`. The new prefix, `is`, shows us that the method conceptually does something different than a `with`. `is` declares that the method sets several interdependent values. The overload shows us which value the parameter `rentedAfterCreate` is dependent on.

The new prefix is also there so that we can recognise whether our builder is starting to become too complex. If the number of `is` methods exceeds the `with`, then our builder is in dangerous waters.

== TestDsl in combination with Spring

The JUnit extension written in part 1 can also be made compatible with `@SpringBootTest`. The extension only has to check whether an ApplicationContext exists. If so, it pulls the floor from the Spring _DI-Container_ instead of from the JUnit Store. (<<lst:testdsl-extension-w-spring>>).

[[lst:testdsl-extension-w-spring]]
.TestDsl with Floor supplied by Spring
[source,java]
----
@Override
public Object resolveParameter(
        ParameterContext parameterContext,
        ExtensionContext extensionContext
    ) throws ParameterResolutionException {
        // ...
        var springFloor = SpringExtension
            .getApplicationContext(extensionContext)
            .getBeanProvider(Floor::class.java)
            .ifAvailable;
        // ...
}
----

Using the annotation, we can now write the test from <<lst:spring-boot-controller-test>>.

[[lst:spring-boot-controller-test]]
.SpringBoot Controller Test with TestDsl
[source,java]
----
@Integration @SpringBootTest @Test // <1>
void should_be_able_to_rent_book_via_api(
        TestState a,
        Floor floor,
        @Autowired BookController testee){ // <2>
    // rest of test
    // <3>
}
----
<1> We combine the SpringBootTest annotation with the TestDsl annotation.
<2> We ask Spring to inject the `testee`.
<3> We can use the TestDsl here as in any other test. The repositories that Spring recognises and those of the TestDsl are the same.

If you use `@SpringBootTest` you have to be careful how you write your tests and how extensive they are. The Spring Application Context is cached for tests and then overrides the test isolation. Modifications that a test makes can cause a test that runs later to fail. This means that tests can no longer be parallelised.

Unit tests should therefore test (functional domains) logic without Spring. This also corresponds to the recommendation that the Spring Framework has made since version 2 <<spring-2-unit-tests>> and has maintained up to the current version 6 <<spring-6-unit-tests>>. An `@Integration @SpringBootTest` is added sporadically for important test paths through the application.

== Low and High Level Test DSLs

The TestDsl for `@Unit` and `@Integration` shown so far is a **Low-Level** TestDsl. It counteracts structure cementation and makes tests ‘under the bonnet’ easier to write. Thanks to direct access to domain objects, we are very flexible as to which test states we can create. We can use it to check the happy path, the sad paths and also many strange paths, i.e. paths that should never actually occur.

However, it is not written from the user's perspective and cannot be used to verify that the system is behaving correctly from the user's perspective. For such tests, we need a running system that we can access from outside via a browser, HttpApi or similar. Google would call these tests ‘Large’ <<google-test-sizes>> (<<tbl:google-test-sizes>>). Other common names are system tests or user acceptance tests.

For these tests, we need a new Dsl with a different structure but a very similar concept behind it. However, this **high-level** `@Acceptance` Dsl no longer has anything to do with structure cementation, but with Ui or Api cementation. The more tests we have that require a certain button or a certain widget, the more this UI component is cemented. In the case of a public api, this cementing is perhaps intentional, as you want to offer others a stable api. But even then, a Dsl is recommended because it makes the tests much more readable and maintainable.

The High-Level TestDsl briefly outlined below is the implementation of the 4 Layer Acceptance Test Structure by Dave Farley <<acceptance-test-dsl>>. The 4 layers are:

1. top: our test
2. DSL per domain: renting, buying, etc.
3. protocol drivers: UI, API, external system stub
4. the system under test

Our test therefore no longer accesses the api of our system directly. There is no `http.get(‘/api/users’)`. The test also does not click directly in the browser. There is no `page.navigate()` or `page.click()`. The test only recognises the next layer, the Dsl.

The Dsl only offers domain-specific user targets, not how the targets are technically implemented (with the `renting`-Dsl we could implement `.findBook(‘Refactoring’).rent()`, for example). It only recognises the protocol drivers and delegates the implementation to the protocol drivers.

Only the drivers know the system to be tested. The UI driver knows how to implement the targets with Playwright, for example, while the Api Protocol Driver can implement the targets using RestAssured, for example. Which driver is used is controlled by annotation (<<lst:high-level-test-dsl>>).

[[lst:high-level-test-dsl]]
.High-Level TestDsl
[source,java]
----
@Acceptance @UiProtocol @ApiProtocol @Test // <1>
void should_be_able_to_rent_book(InventoryDsl inventory, RentingDsl renting){
    // given
    inventory.addBook("Refactoring"); // <2> <3>
    var book = renting.findBook("Refactoring");
    // when
    book.rent();
    // then
    assertThat(book.isRented()).isTrue();
}
----
<1> We carry out this test via the browser but also via the HttpApi.
<2> As with the low-level Dsl, each test must create its complete state.
<3> Unlike the low-level Dsl, however, this Dsl takes significantly larger steps. Creating a book can consist of many browser actions or api calls. If one of the intermediate steps fails, the Dsl aborts immediately and provides specific feedback as to which of the intermediate steps did not work.

You can also **parallelize** these tests in a similar way as we have done with integration tests: we can either provide a namespace per test directly in our system under test or solve this via our Dsl.

The former is possible if you build multi-client capability into your system right from the start. Each entity then needs a 'client ID' and you have to ensure that everyone can only see the data of their own client. If you now create a new client for each test and the test also creates all preconditions in the form of entities, then the tests are isolated from each other via the client ID and can therefore be parallelized.

If the tenant ID cannot be built directly into the system, the test data aliasing <<acceptance-test-dsl>> mentioned by Dave Farley is used. With this procedure, the TestDsl itself ensures that the test data is unique. It then adds a test-unique key to fields. `addBook(“Refactoring”)` does not create the book “Refactoring”, but the book “Refactoring dbac1q23”. `findBook(“Refactoring”)` does not search for “Refactoring”, but for “Refactoring dbac1q23”. When writing the test, however, you must be careful not to assert the number of books or similar, as this could change continuously due to tests running in parallel.

Overall, the high-level Dsl described here supplements the low-level Dsl with the user view. We write the majority of the tests with the low-level Dsl; we test critical application areas in particular with the high-level Dsl from the user's perspective.

== Outlook

The TestDsl combines existing concepts such as builders, ports <<ports-and-adapters>>, port contract tests <<port-contract-test>>, stubs <<mocks-arent-stubs>> and fakes <<xunit-fake>> and provides a standardized api for all our unit and integration tests. With the TestDsl, we were able to solve structure cementation through redundant test setup. We will show how we use the TestDsl to prevent structure cementing through tests at the wrong level in Part 3.

If you are more interested in the topic, you can view TestDsl sample code online <<test-dsl>> or watch the presentation on “Beehive Architecture” <<beehive-architecture>>, which also revolves around the TestDsl.

[bibliography]
== References

* [[[dsl, 1]]] M. Fowler, „Domain Specific Language“. 2008. Available here: link:https://martinfowler.com/bliki/DomainSpecificLanguage.html[]
* [[[test-shapes, 2]]] M. Fowler, „On the Diverse And Fantastical Shapes of Testing“. 2021. Available here: link:https://martinfowler.com/articles/2021-test-shapes.html[]
* [[[google-test-sizes, 3]]] S. Stewart, „Test Sizes“. 2010. Available here: link:https://testing.googleblog.com/2010/12/test-sizes.html[]
* [[[fowler-unit-test, 4]]] M. Fowler, „Unit Test“. 2014. Available here: link:https://martinfowler.com/bliki/UnitTest.html#SolitaryOrSociable[]
* [[[feathers-unit-test, 5]]] M. Feathers, „A Set of Unit Testing Rules“. 2005. Available here: link:https://www.artima.com/weblogs/viewpost.jsp?thread=126923[]
* [[[ports-and-adapters, 6]]] A. Cockburn, „Hexagonal architecture“. 2005. Available here: link:https://alistair.cockburn.us/hexagonal-architecture/[]
* [[[port-contract-test, 7]]] R. Gross, „Contract Tests in Kotlin“. 2020. Available here: link:http://richargh.de/posts/Contract-Tests-in-Kotlin[]
* [[[xunit-test-double, 8]]] G. Meszaros, „Test Double“. 2011. Available here: link:http://xunitpatterns.com/Test%20Double.html[]
* [[[xunit-fake, 9]]] G. Meszaros, „Fake Object“. 2011. Available here: link:http://xunitpatterns.com/Fake%20Object.html[]
* [[[mocks-arent-stubs, 10]]] M. Fowler, „Mocks Aren’t Stubs“. 2007. Available here: link:https://martinfowler.com/articles/mocksArentStubs.html[]
* [[[contract-tests, 11]]] J. B. Rainsberger, „Getting Started with Contract Tests“. 2017. Available here: link:https://blog.thecodewhisperer.com/permalink/getting-started-with-contract-tests[]
* [[[integration-contract-tests, 12]]] M. Fowler, „Integration Contract Test“. 2011. Available here: link:https://martinfowler.com/bliki/ContractTest.html[]
* [[[consumer-driven-contracts, 13]]] I. Robinson, „Consumer-Driven Contracts: A Service Evolution Pattern“. 2006. Available here: link:https://martinfowler.com/articles/consumerDrivenContracts.html[]
* [[[role-tests, 14]]] M. Rivero, „Role tests for implementation of interfaces discovered through TDD“. 2022. Available here: link:https://codesai.com/posts/2022/04/role-tests[]
* [[[xunit-stub, 15]]] G. Meszaros, „Test Stub“. 2011. Available here: link:http://xunitpatterns.com/Test%20Stub.html[]
* [[[xunit-mock, 16]]] G. Meszaros, „Mock Object“. 2011. Available here: link:http://xunitpatterns.com/Mock%20Object.html[]
* [[[stubs-and-mocks-break-encapsulation, 17]]] M. Seemann, „Stubs and mocks break encapsulation“. 2022. Available here: link:https://blog.ploeh.dk/2022/10/17/stubs-and-mocks-break-encapsulation/[]
* [[[art-of-unit-testing, 18]]] R. Osherove, „Art of Unit Testing (3. Edition)“. 2024. Available here: link:https://www.artofunittesting.com/[]
* [[[stringly-typed, 19]]] T. Spring, „Stringly Typed vs Strongly Typed“. 2022. Available here: link:https://www.hanselman.com/blog/stringly-typed-vs-strongly-typed[]
* [[[spring-2-unit-tests, 20]]] T. Spring, „Unit Testing“. 2006. Available here: link:https://docs.spring.io/spring-framework/docs/2.0.4/reference/testing.html#unit-testing[]
* [[[spring-6-unit-tests, 21]]] T. Spring, „Unit Testing“. 2022. Available here: link:https://docs.spring.io/spring-framework/docs/6.0.0/reference/html/testing.html#unit-testing[]
* [[[acceptance-test-dsl, 22]]] D. Farley, „Acceptance Testing for Continuous Delivery [#AgileIndia2019]“. 2019. Available here: link:https://www.youtube.com/watch?v=Rmz3xobXyV4[]
* [[[richargh-contract-tests, 23]]] R. Gross, „Contract Tests in Kotlin“. 2020. Available here: link:http://richargh.de/posts/Contract-Tests-in-Kotlin[]
* [[[test-dsl, 24]]] R. Gross, „TestDsl (Avoid structure-cementing Tests)“. 2024. Available here: link:https://github.com/Richargh/testdsl[]
* [[[beehive-architecture, 25]]] R. Gross, „Beehive Architecture“. 2023. Available here: link:http://richargh.de/talks/#beehive-architecture[]
